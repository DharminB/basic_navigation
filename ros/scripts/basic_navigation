#! /usr/bin/env python

from __future__ import print_function

import tf
import copy
import math
import rospy
from nav_msgs.msg import OccupancyGrid, Path
from geometry_msgs.msg import PoseStamped, Pose, TransformStamped, Quaternion
from geometry_msgs.msg import Twist, PoseWithCovarianceStamped, Point
from navfn.srv import MakeNavPlan, MakeNavPlanRequest, MakeNavPlanResponse

class Utils(object):

    """Utility functions used for 2d navigation"""

    @staticmethod
    def get_pose_from_x_y_theta(x, y, theta):
        """Return a Pose object from x, y and theta
        :x: float
        :y: float
        :theta: float
        :returns: geometry_msgs.Pose

        """
        pose = Pose()
        pose.position.x = x
        pose.position.y = y

        quat = tf.transformations.quaternion_from_euler(0.0, 0.0, theta)
        pose.orientation = Quaternion(*quat)
        return pose

    @staticmethod
    def get_pose_stamped_from_frame_x_y_theta(frame, x, y, theta):
        """Return a Pose object from x, y and theta
        :x: float
        :y: float
        :theta: float
        :frame: string
        :returns: geometry_msgs.PoseStamped

        """
        pose = PoseStamped()
        pose.pose = Utils.get_pose_from_x_y_theta(x, y, theta)
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = frame
        return pose

    @staticmethod
    def get_x_y_theta_from_pose(pose):
        """Return a tuple(x, y, theta) from Pose objects

        :pose: geometry_msgs/Pose
        :returns: tuple(x, y, theta)

        """
        quat = (pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w)
        theta = tf.transformations.euler_from_quaternion(quat)[2]
        return (pose.position.x, pose.position.y, theta)

    @staticmethod
    def get_static_transform_from_x_y_theta(x, y, theta, frame_id="odom"):
        """Create a TransformedStamped message from x y and theta to 0, 0 and 0
        
        :x: float
        :y: float
        :theta: float
        :returns: geometry_msgs.TransformStamped
        """
        transform = TransformStamped()
  
        transform.header.stamp = rospy.Time.now()
        transform.header.frame_id = frame_id
        transform.child_frame_id = "start_pose"
  
        transform.transform.translation.x = x
        transform.transform.translation.y = y
        transform.transform.translation.z = 0.0
  
        quat = tf.transformations.quaternion_from_euler(0.0, 0.0, theta)
        transform.transform.rotation = Quaternion(*quat)
        return transform

    @staticmethod
    def get_shortest_angle(angle1, angle2):
        """Compute the angular distance between two angles (in radians)

        :angle1: float
        :angle2: float
        :returns: float
        """
        return math.atan2(math.sin(angle1 - angle2), math.cos(angle1 - angle2))

    @staticmethod
    def get_distance(delta_x, delta_y):
        """Compute cartesian distance given individual distance in x and y axis

        :delta_x: float
        :delta_y: float
        :returns: float

        """
        return (delta_x**2 + delta_y**2)**0.5

    @staticmethod
    def get_distance_between_points(p1, p2):
        """Compute cartesian distance given two points

        :p1: tuple(float, float)
        :p2: tuple(float, float)
        :returns: float

        """
        return Utils.get_distance(p1[0]-p2[0], p1[1]-p2[1])

    @staticmethod
    def clip(value, max_allowed=1.0, min_allowed=0.1):
        """Clip the provided value to be between the given range

        :value: float
        :max_allowed: float
        :min_allowed: float
        :returns: float

        """
        sign = 1.0 if value > 0.0 else -1.0
        return sign * min(max_allowed, max(min_allowed, abs(value)))

    @staticmethod
    def get_twist(x=0.0, y=0.0, theta=0.0):
        """Return twist ros message object.

        :x: float
        :y: float
        :theta: float
        :returns: geometry_msgs.msg.Twist

        """
        msg = Twist()
        msg.linear.x = x
        msg.linear.y = y
        msg.angular.z = theta
        return msg


class BasicNavigation(object):

    """Navigation to move in a straight line towards a goal"""

    def __init__(self):
        # Class variables
        self.goal = None
        self.curr_pos = None
        self.plan = None
        self.reached_goal_once = False
        self.global_frame = rospy.get_param('~global_frame', 'map')
        self.use_global_planner = rospy.get_param('~use_global_planner', False)
        self.num_of_retries = rospy.get_param('~num_of_retries', 3)
        self.retry_attempts = 0

        # tolerances
        self.heading_tolerance = rospy.get_param('~heading_tolerance', 0.5)
        self.goal_dist_tolerance = rospy.get_param('~goal_dist_tolerance', 0.1)
        self.goal_theta_tolerance = rospy.get_param('~goal_theta_tolerance', 0.1)
        self.latch_xy_goal = rospy.get_param('~latch_xy_goal', True)
        self.dist_between_wp = rospy.get_param('~dist_between_wp', 1.0)
        self.waypoint_dist_tolerance = rospy.get_param('~waypoint_dist_tolerance', 0.3)
        max_safe_costmap_val = rospy.get_param('~max_safe_costmap_val', 80)

        # controller params
        self.p_theta_in_place = rospy.get_param('p_theta_in_place', 5.0)
        self.p_theta = rospy.get_param('p_theta', 1.0)
        self.p_linear = rospy.get_param('p_linear', 1.0)
        self.max_theta_vel = rospy.get_param('~max_theta_vel', 0.5)
        self.min_theta_vel = rospy.get_param('~min_theta_vel', 0.005)
        self.max_linear_vel = rospy.get_param('~max_linear_vel', 0.3)
        self.min_linear_vel = rospy.get_param('~min_linear_vel', 0.1)
        self.future_pos_lookahead_dist = rospy.get_param('~future_pos_lookahead_dist', 0.4)

        self.costmap_to_vel_multiplier = (self.max_linear_vel-self.min_linear_vel)/max_safe_costmap_val

        # Publishers
        self._cmd_vel_pub = rospy.Publisher('~cmd_vel', Twist, queue_size=1)
        self._path_pub = rospy.Publisher('~path', Path, queue_size=1)

        # Subscribers
        costmap_sub = rospy.Subscriber('~costmap', OccupancyGrid, self.costmap_cb)
        goal_sub = rospy.Subscriber('~goal', PoseStamped, self.goal_cb)
        localisation_sub = rospy.Subscriber('~localisation', PoseWithCovarianceStamped, self.localisation_cb)

        # Service client
        global_planner_service_topic = rospy.get_param('~global_planner_service', 'make_plan')
        rospy.wait_for_service(global_planner_service_topic)
        self.call_global_planner = rospy.ServiceProxy(global_planner_service_topic, MakeNavPlan)

        rospy.sleep(0.5)
        rospy.loginfo('Initialised')

    def run_once(self):
        """
        Main event loop
        """
        if self.goal is None:
            return

        if self.curr_pos is None:
            rospy.logwarn('Current pose is not available')
            return

        if self.plan is None:
            if self.use_global_planner:
                rospy.loginfo('Trying to get global plan')
                self._get_global_plan()
                return
            else:
                rospy.loginfo('Getting straight line path')
                self._get_straight_line_plan()
                return

        curr_goal = Utils.get_x_y_theta_from_pose(self.plan[0].pose)
        dist = Utils.get_distance_between_points(self.curr_pos[:2], curr_goal[:2])
        if len(self.plan) == 1 and (dist < self.goal_dist_tolerance or (self.latch_xy_goal and self.reached_goal_once)) :
            self.reached_goal_once = True
            angular_dist = Utils.get_shortest_angle(curr_goal[2], self.curr_pos[2])
            if abs(angular_dist) < self.goal_theta_tolerance:
                rospy.loginfo('REACHED GOAL')
                self.publish_zero_vel()
                self.goal = None
                self.plan = None
                self.reached_goal_once = False
                return
            else:
                self._rotate_in_place(theta_error=angular_dist)
                return
        if dist < self.waypoint_dist_tolerance and len(self.plan) > 1:
            rospy.loginfo('Reached waypoint')
            self.plan.pop(0)

        heading = math.atan2(curr_goal[1]-self.curr_pos[1], curr_goal[0]-self.curr_pos[0])
        # heading_diff = heading - self.curr_pos[2]
        heading_diff = Utils.get_shortest_angle(heading, self.curr_pos[2])
        if abs(heading_diff) > self.heading_tolerance:
            self._rotate_in_place(theta_error=heading_diff)
        else:
            self._move_forward(pos_error=dist, theta_error=heading_diff)

    def _rotate_in_place(self, theta_error=1.0):
        theta_vel_raw = theta_error * self.p_theta_in_place
        theta_vel = Utils.clip(theta_vel_raw, self.max_theta_vel, self.min_theta_vel)
        self._cmd_vel_pub.publish(Utils.get_twist(x=0.0, y=0.0, theta=theta_vel))

    def _move_forward(self, pos_error=1.0, theta_error=1.0):
        future_vel_costmap = self._get_vel_based_on_costmap()
        if future_vel_costmap < self.min_linear_vel:
            rospy.logerr('Obstacle ahead. Current plan failed.')
            if self.retry_attempts < self.num_of_retries:
                rospy.loginfo('Retrying')
                self.retry_attempts += 1
                self.publish_zero_vel()
                self.plan = None
            else:
                rospy.logerr('ABORTING')
                self.publish_zero_vel()
                self.goal = None
            return

        future_vel_prop_raw = pos_error * self.p_linear
        future_vel_prop = Utils.clip(future_vel_prop_raw, self.max_linear_vel, self.min_linear_vel)

        x_vel = min(future_vel_costmap, future_vel_prop)
        theta_vel_raw = theta_error * self.p_theta
        theta_vel = Utils.clip(theta_vel_raw, self.max_theta_vel, self.min_theta_vel)
        self._cmd_vel_pub.publish(Utils.get_twist(x=x_vel, y=0.0, theta=theta_vel))

    def goal_cb(self, msg):
        self.goal = Utils.get_x_y_theta_from_pose(msg.pose)
        rospy.loginfo(self.goal)
        if self.plan is not None:
            self.plan = None
            rospy.logwarn('Preempting current goal. User requested another goal')

    def localisation_cb(self, msg):
        self.curr_pos = Utils.get_x_y_theta_from_pose(msg.pose.pose)

    def costmap_cb(self, msg):
        self.costmap_msg = msg

    def _get_global_plan(self):
        """Call global planner to get a plan based on current position and goal

        :returns: None

        """
        plan = []
        req = MakeNavPlanRequest()
        req.goal = Utils.get_pose_stamped_from_frame_x_y_theta(self.global_frame,
                                                               *self.goal)
        req.start = Utils.get_pose_stamped_from_frame_x_y_theta(self.global_frame,
                                                                *self.curr_pos)
        try:
            response = self.call_global_planner(req)
            if len(response.path) > 0:
                plan = response.path
        except rospy.ServiceException as e:
            rospy.logerr('Global planner failed.')
            rospy.logerr(str(e))
            return

        first_pose = Utils.get_x_y_theta_from_pose(plan[0].pose)
        second_pose = Utils.get_x_y_theta_from_pose(plan[1].pose)
        avg_dist = Utils.get_distance_between_points(first_pose[:2], second_pose[:2])
        index_offset = int(round(self.dist_between_wp/avg_dist))
        self.plan = []
        for i in range(0, len(plan), index_offset):
            self.plan.append(plan[i])
        self.plan.append(plan[-1])

        # publish path
        path_msg = Path()
        path_msg.header.frame_id = self.global_frame
        path_msg.header.stamp = rospy.Time.now()
        path_msg.poses = self.plan
        self._path_pub.publish(path_msg)

    def _get_straight_line_plan(self):
        """
        Generate a straight line path to reach goal
        """
        self.plan = []
        path_msg = Path()
        path_msg.header.frame_id = self.global_frame
        path_msg.header.stamp = rospy.Time.now()

        start_pose = Utils.get_pose_stamped_from_frame_x_y_theta(self.global_frame,
                                                                 *self.curr_pos)
        goal_pose = Utils.get_pose_stamped_from_frame_x_y_theta(self.global_frame,
                                                                *self.goal)
        self.plan.append(start_pose)
        self.plan.append(goal_pose)
        path_msg.poses = self.plan

        self._path_pub.publish(path_msg)

    def _get_costmap_value_at(self, x=0.0, y=0.0):
        """
        # Assumption: costmap's global_frame is map
        :x: float
        :y: float
        
        :returns: int (between -1 and 100)
        """
        costmap_origin_x = self.costmap_msg.info.origin.position.x
        costmap_origin_y = self.costmap_msg.info.origin.position.y
        diff_x = x - costmap_origin_x
        diff_y = y - costmap_origin_y
        if diff_x < 0 or diff_y < 0:
            return -1
        i = int(round(diff_x/self.costmap_msg.info.resolution))
        j = int(round(diff_y/self.costmap_msg.info.resolution))
        if i > self.costmap_msg.info.width or j > self.costmap_msg.info.height:
            return -1
        return self.costmap_msg.data[j * self.costmap_msg.info.width + i]

    def _get_vel_based_on_costmap(self):
        future_pos = (self.curr_pos[0] + self.future_pos_lookahead_dist * math.cos(self.curr_pos[2]),
                      self.curr_pos[1] + self.future_pos_lookahead_dist * math.sin(self.curr_pos[2]))
        future_costmap_value = self._get_costmap_value_at(*future_pos)
        future_vel = self.max_linear_vel - (future_costmap_value * self.costmap_to_vel_multiplier)
        return future_vel
        
    def publish_zero_vel(self):
        self._cmd_vel_pub.publish(Utils.get_twist())


if __name__ == "__main__":
    rospy.init_node('basic_navigation')
    BN = BasicNavigation()
    CONTROL_RATE = rospy.get_param('~control_rate', 1.0)
    RATE = rospy.Rate(CONTROL_RATE)
    try:
        while not rospy.is_shutdown():
            BN.run_once()
            RATE.sleep()
    except Exception as e:
        rospy.logerr(str(e))
    rospy.loginfo('Exiting.')
